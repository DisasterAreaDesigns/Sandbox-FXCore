<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FXCore Assembler</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="icon" href="favicon.ico">
</head>

<body>
    <div class="container">

        <!-- Monaco Editor Loader -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script>
        <script>
        let editor; // global editor instance
        require.config({
            paths: {
                'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.39.0/min/vs'
            }
        });
        require(['vs/editor/editor.main'], function() {
            // Register the FXCore language
            monaco.languages.register({
                id: 'fxcore'
            });

monaco.languages.setMonarchTokensProvider('fxcore', {
    ignoreCase: true,
    tokenizer: {
        root: [
            // Line Comments
            [/;.*/, 'comment'],
            [/\/\/.*/, 'comment'],

            // Block Comment Start → enter comment state
            [/\/\*/, 'comment', '@comment'],

            // Strings → enter string mode
            ['"', { token: 'string.quote', next: '@string' }],

            // Labels at start of line (must come early)
            [/^\s*([a-zA-Z_][\w]*):/, 'label'],

            // Declarations
            [/\.(mem|equ|rn)\b/, 'keyword.declaration'],

            // Constants
            [/\b(LFO[0-3]|SIN|COS|POS|NEG|RMP[0-1]|L512|L1024|L2048|L4096|XF[0-3]|USER[0-1])\b/, 'constant'],
            [/\b(OUT[0-3]OFLO|IN[0-3]OFLO)\b/, 'constant'],
            [/\b(TB2NTB1|TAPSTKY|NEWTT|TAPRE|TAPPE|TAPLVL)\b/, 'constant'],
            [/\b(SW[0-4](DB|RE|PE)?)\b/, 'constant'],
            [/\b(ENABLEDB?|PLLRANGE[01]|MNS|I2CA[0-6]|TAP)\b/, 'constant'],
            [/\bPR(1[0-5]|[0-9])\b/, 'constant'],

            // Registers
            [/\b(r1[0-5]|r[0-9]|acc(32|64)|flags|in[0-3]|out[0-3]|pin|switch|pot[0-5](_k|_smth)?|lfo[0-3]_[fsc]|ramp[0-1]_[fr]|maxtempo|taptempo|samplecnt|noise|bootstat|tapstkrld|tapdbrld|swdbrld|prgdbrld|oflrld|mr(1[0-2][0-7]|[1-9][0-9]|[0-9]))\b/, 'variable'],

            // Operators
            [/\b(abs|clracc64|addi|add|adds|addsi|sub|subs|sl|slr|sls|slsr|sr|srr|sra|srar|macrr|macri|macrd|macid|machrr|machri|machrd|machid|multrr|multri|neg|log2|exp2)\b/, 'keyword'],

            // Control Flow
            [/\b(jgez|jneg|jnz|jz|jzc|jmp)\b/, 'keyword'],

            // Copy Operations
            [/\b(cpy_cc|cpy_cm|cpy_cs|cpy_mc|cpy_sc|cpy_cmx)\b/, 'keyword'],

            // Memory and Delay Operations
            [/\b(rdacc64u|rdacc64l|ldacc64u|ldacc64l|rddel|wrdel|rddelx|wrdelx|rddirx|wrdirx|sat65|wrdld)\b/, 'keyword'],

            // Logical Operations
            [/\b(inv|or|ori|and|andi|xor|xori)\b/, 'keyword'],

            // Audio Processing
            [/\b(apa|apb|apra|aprb|aprra|aprrb|apma|apmb|chr|pitch|set|interp)\b/, 'keyword'],

            // Hex Numbers
            [/\b0[xX][0-9A-Fa-f]+\b/, 'number.hex'],

            // Decimal Numbers
            [/\b\d+(\.\d+)?\b/, 'number'],

            // Identifiers
            [/\b[a-zA-Z_][\w]*\b/, 'identifier'],
        ],

        // String mode → everything inside quotes
        string: [
            [/[^"]+/, 'string'],
            ['"', { token: 'string.quote', next: '@pop' }]
        ],

        // Block Comment mode
        comment: [
            [/[^\/*]+/, 'comment'],
            [/\*\//, 'comment', '@pop'],
            [/[\/*]/, 'comment']
        ]
    }
});


            monaco.editor.defineTheme('fxcoreTheme', {
                base: 'vs', // or 'vs-dark'
                inherit: true,
                rules: [{
                        token: 'keyword.operator',
                        foreground: 'aa00ff',
                        fontStyle: 'bold'
                    },
                    {
                        token: 'keyword.control',
                        foreground: 'ff0000',
                        fontStyle: 'bold'
                    },
                    {
                        token: 'keyword.other',
                        foreground: '0066cc',
                        fontStyle: 'bold'
                    },
                    {
                        token: 'keyword.declaration',
                        foreground: '006600',
                        fontStyle: 'bold'
                    },
                    {
                        token: 'keyword.constant',
                        foreground: 'cc6600',
                        fontStyle: 'bold'
                    },
                    {
                        token: 'comment',
                        foreground: '008000',
                        fontStyle: 'italic'
                    },
                    {
                        token: 'label',
                        foreground: '0000ff'
                    },
                    {
                        token: 'number',
                        foreground: 'ff0000'
                    },
                    {
                        token: 'number.hex',
                        foreground: 'ff6600'
                    },
                    {
                        token: 'string',
                        foreground: 'a31515'
                    }
                ],
                colors: {
                    'editor.foreground': '#000000',
                    'editor.background': '#ffffff',
                    'editorLineNumber.foreground': '#999999',
                    'editorCursor.foreground': '#000000',
                    'editor.selectionBackground': '#BAD6FD',
                    'editor.lineHighlightBackground': '#f0f8ff'
                }
            });

            monaco.editor.defineTheme('fxcoreTheme', {
    base: 'vs-dark',
    inherit: true,
    rules: [
        {
            token: 'keyword.operator',
            foreground: 'd986ff',
            fontStyle: 'bold'
        },
        {
            token: 'keyword.control',
            foreground: 'ff7070',
            fontStyle: 'bold'
        },
        {
            token: 'keyword.other',
            foreground: '6699ff',
            fontStyle: 'bold'
        },
        {
            token: 'keyword.declaration',
            foreground: '66cc66',
            fontStyle: 'bold'
        },
        {
            token: 'keyword.constant',
            foreground: 'ffbb55',
            fontStyle: 'bold'
        },
        {
            token: 'comment',
            foreground: '6a9955',
            fontStyle: 'italic'
        },
        {
            token: 'label',
            foreground: '569cd6'
        },
        {
            token: 'number',
            foreground: 'f44747'
        },
        {
            token: 'number.hex',
            foreground: 'ff8800'
        },
        {
            token: 'string',
            foreground: 'ce9178'
        }
    ],
    colors: {
        'editor.foreground': '#d4d4d4',
        'editor.background': '#1e1e1e',
        'editorLineNumber.foreground': '#858585',
        'editorCursor.foreground': '#ffffff',
        'editor.selectionBackground': '#264f78',
        'editor.lineHighlightBackground': '#333333'
    }
});


            // Create the Monaco Editor
            editor = monaco.editor.create(document.getElementById('editor'), {
                language: 'fxcore',
                theme: 'fxcoreDark',
                automaticLayout: true,
                quickSuggestions: false,
                wordBasedSuggestions: false,
                minimap: {
                    enabled: false
                }
            });

            // Disable browser autocorrect on Monaco's hidden textarea
            setTimeout(() => {
                const textAreas = document.querySelectorAll('textarea');
                textAreas.forEach(textArea => {
                    textArea.setAttribute('spellcheck', 'false');
                    textArea.setAttribute('autocorrect', 'off');
                    textArea.setAttribute('autocomplete', 'off');
                    textArea.setAttribute('autocapitalize', 'off');
                });
            }, 500);
        });
        </script>

        <div class="header-bar">
            <h1>FXCore Assembler <span class="build">build 03</span></h1>
            <img src="icon.png" alt="App Icon" class="app-icon">
        </div>

        <h2>Input Source Code</h2>
        <div class="file-input">
            <input type="file" id="fileInput" accept=".fxc,.fxo,.asm,.txt" style="display: none;" onchange="loadFile()">
            <button onclick="document.getElementById('fileInput').click()">Load File...</button>

            <div class="example-buttons">
                <span>Or select an example program:</span>
                <div class="button-grid">
                    <button onclick="loadExample('fxcore_passthrough')">FXCore Pass-through</button>
                    <button onclick="loadExample('fxcore_delay')">FXCore Delay</button>
                    <button onclick="loadExample('fxcore_filter')">FXCore Filter</button>
                </div>
            </div>
        </div>

        <div class="editor-container">
            <div id="editor" style="width: 100%; height: 400px;"></div>
        </div>
        <div class="editor-help-text">
            <label>
                <span class="shortcut">Editor Shortcuts active when cursor is in editor window:</span>
                <span class="shortcut">Ctrl+F / ⌘+F Find</span>
                <span class="shortcut">Ctrl+H / ⌘+H Replace</span>
                <span class="shortcut">F3 Find Next</span>
            </label>
        </div>

        <div class="options">
            <label>
                <input type="checkbox" id="editorHeightToggle" onchange="toggleEditorHeight()"> Large editor window
            </label>
            <label>
                <input type="checkbox" id="darkModeToggle" onchange="toggleDarkMode()"> Enable dark mode
            </label>
            <label>
                <input type="checkbox" id="minimapToggle" onchange="toggleMinimap()"> Show editor mini-map
            </label>
        </div>

        <div>
            <button onclick="assembleFXCore()">Assemble</button>
            <button onclick="clearAssembly()">Clear Assembly</button>
            <button onclick="saveSource()">Save Source...</button>
        </div>

        <div id="messages"></div>

        <div class="output-section">
            <h2>Output</h2>
            <div class="output-controls">
                <div>
                    <button onclick="downloadHex()" id="downloadHexBtn" disabled>Download HEX</button>
                    <button onclick="downloadBinary()" id="downloadBinBtn" disabled>Download Binary</button>
                </div>
            </div>

            <div class="output-text-section">
                <h3 onclick="toggleOutput()" style="cursor: pointer; user-select: none; margin-bottom: 10px;">
                    <span id="outputToggle">▶</span> Assembly Output
                </h3>
                <div id="outputContent" class="output-content collapsed">
                    <textarea id="output" readonly placeholder="FXCore assembly output will appear here..."></textarea>
                </div>
            </div>
        </div>

        <footer style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #ddd; font-size: 11px; color: #666; line-height: 1.4;">
            <p><strong>MIT License</strong></p>
            <p>FXCore Assembler with Monaco Editor integration</p>
            <p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
                SOFTWARE.</p>
        </footer>

        <!-- FXCore Assembler Scripts -->
        <script src="debug_config.js"></script>
        <script src="common.js"></script>
        <script src="reserved_words.js"></script>
        <script src="registers.js"></script>
        <script src="mnemonic.js"></script>
        <script src="shunting_yard.js"></script>
        <script src="line_parse.js"></script>
        <script src="intel_hex.js"></script>
        <script src="symbol_table.js"></script>
        <script src="fxcore_ic.js"></script>
        <script src="assembler.js"></script>
        <script src="program.js"></script>

        <script>
        // Global variables and functions to integrate FXCore with Monaco editor
        let assembledData = null;

        // Initialize the FXCore assembler when the page loads
        document.addEventListener('DOMContentLoaded', function() {
            DEBUG.reset();
            // DEBUG.setPreset('full');
            DEBUG.showConfig();
            
            // Override FXCoreAssembler.logMessage to work with our DOM structure
            if (typeof FXCoreAssembler !== 'undefined') {
                FXCoreAssembler.logMessage = function(message, type = 'info') {
                    const timestamp = new Date().toLocaleTimeString();
                    const outputArea = document.getElementById('output');
                    const messagesArea = document.getElementById('messages');
                    
                    // Log to console for debugging
                    console.log(`[${timestamp}] ${type.toUpperCase()}: ${message}`);
                    
                    // Add to output area if it exists
                    // if (outputArea) {
                    //     const currentContent = outputArea.value;
                    //     outputArea.value = currentContent + `[${timestamp}] ${message}\n`;
                    //     outputArea.scrollTop = outputArea.scrollHeight;
                    // }
                    
                    // Show critical messages in the messages area
                    // if ((type === 'error' || type === 'success') && messagesArea) {
                    //     const messageClass = type === 'error' ? 'error' : 'success';
                    //     messagesArea.innerHTML = `<div class="${messageClass}">${message}</div>`;
                    // }
                };
            }
            
            console.log('FXCore assembler libraries loaded');
        });

        // Load file function adapted for Monaco editor
        function loadFile() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    if (editor) {
                        editor.setValue(e.target.result);
                    }
                };
                reader.readAsText(file);
            }
        }

        // Example loader function
        function loadExample(exampleName) {
            let code = '';
            switch(exampleName) {
                case 'fxcore_passthrough':
                    code = `; FXCore Simple Pass-through
; Input -> Output with no processing

cpy_cs  acc32, in0      ; read input from left ADC
cpy_sc  out0, acc32     ; write accumulator to left DAC
cpy_cs  acc32, in1      ; read input from right ADC
cpy_sc  out1, acc32     ; and write accumulator to DAC
`;
                    break;
                case 'fxcore_delay':
                    code = `; FXCore Simple Delay
; Basic delay effect

    MEM     delay_buffer 1000   ; Delay buffer

start:
    IN      R0                  ; Read input
    LD      R1, delay_buffer    ; Load delayed sample
    ADD     R2, R0, R1          ; Mix input with delay
    ST      delay_buffer, R0    ; Store current sample
    OUT     R2                  ; Output mixed signal
    JMP     start               ; Loop forever
`;
                    break;
                case 'fxcore_filter':
                    code = `; FXCore Simple Filter
; Basic low-pass filter

start:
    IN      R0          ; Read input
    FILT    R1, R0      ; Apply filter
    OUT     R1          ; Output filtered signal
    JMP     start       ; Loop forever
`;
                    break;
            }
            if (editor) {
                editor.setValue(code);
            }
        }

function assembleFXCore() {
    if (!editor) {
        debugLog('Editor not initialized', 'errors');
        return;
    }

    const sourceCode = editor.getValue();
    if (!sourceCode.trim()) {
        debugLog('No source code to assemble', 'errors');
        return;
    }

    try {
        // Clear previous message
        document.getElementById('messages').innerHTML = '';

        if (typeof FXCoreAssembler !== 'undefined') {
            // Set source and prep for assembly
            FXCoreAssembler.sourceCode = sourceCode;
            Program.filename = 'editor_source.fxc';
            FXCoreAssembler.assembledHex = null;

            const assembleSuccess = Program.Asm_it();

            if (assembleSuccess && FXCoreAssembler.assembledHex) {
                assembledData = FXCoreAssembler.assembledHex;
                document.getElementById('output').value = FXCoreAssembler.assembledHex;
                document.getElementById('downloadHexBtn').disabled = false;
                document.getElementById('downloadBinBtn').disabled = false;

                debugLog('Assembly completed successfully', 'success');
            } else {
                // Clear any prior output if needed
                document.getElementById('output').value = '';
                debugLog('Assembly failed', 'errors');

            }
        } else {
            debugLog('FXCoreAssembler class not available', 'errors');
        }

        // Show output section
        // const outputContent = document.getElementById('outputContent');
        // const outputToggle = document.getElementById('outputToggle');
        // outputContent.classList.remove('collapsed');
        // outputToggle.textContent = '▼';

    } catch (error) {
        debugLog('Assembly error: ' + error.message, 'errors');
        debugLog('FXCoreAssembler class not found', 'errors');


        // Show output section even on error
        const outputContent = document.getElementById('outputContent');
        const outputToggle = document.getElementById('outputToggle');
        outputContent.classList.remove('collapsed');
        outputToggle.textContent = '▼';

        console.error('Assembly error:', error);
    }
}

        // Clear assembly function
        function clearAssembly() {
            document.getElementById('output').value = '';
            document.getElementById('messages').innerHTML = '';
            document.getElementById('downloadHexBtn').disabled = true;
            document.getElementById('downloadBinBtn').disabled = true;
            assembledData = null;
        }

        // Save source function
        function saveSource() {
            if (!editor) return;
            
            const sourceCode = editor.getValue();
            const blob = new Blob([sourceCode], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'fxcore_source.fxc';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Download functions
        function downloadHex() {
            if (!assembledData) {
                document.getElementById('messages').innerHTML = '<div class="error">No assembled data available</div>';
                return;
            }
            
            const blob = new Blob([assembledData], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'output.hex';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function downloadBinary() {
            if (!assembledData) {
                document.getElementById('messages').innerHTML = '<div class="error">No assembled data available</div>';
                return;
            }
            
            // For Intel HEX format, we'd need to parse it to binary
            // For now, just download the hex as is
            const blob = new Blob([assembledData], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'output.bin';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Toggle minimap function
        function toggleMinimap() {
            if (editor) {
                const minimapEnabled = document.getElementById('minimapToggle').checked;
                editor.updateOptions({
                    minimap: { enabled: minimapEnabled }
                });
            }
        }

// toggle dark mode for editor
function toggleDarkMode() {
    if (editor) {
        const darkModeEnabled = document.getElementById('darkModeToggle').checked;
        const theme = darkModeEnabled ? 'fxcoreTheme' : 'fxcoreDark' ;
        monaco.editor.setTheme(theme);
    }
}

// toggle dark mode for editor
function toggleEditorHeight() {
    if (editor) {
        const editorContainer = editor.getDomNode().parentElement;
        if (editorContainer) {
            editorContainer.style.height = document.getElementById('editorHeightToggle').checked
                ? '800px'
                : '400px';
            editor.layout();
        }
    }
}


        // Toggle output function
        function toggleOutput() {
            const outputContent = document.getElementById('outputContent');
            const outputToggle = document.getElementById('outputToggle');
            
            if (outputContent.classList.contains('collapsed')) {
                outputContent.classList.remove('collapsed');
                outputToggle.textContent = '▼';
            } else {
                outputContent.classList.add('collapsed');
                outputToggle.textContent = '▶';
            }
        }
        </script>
    </div>
</body>

</html>