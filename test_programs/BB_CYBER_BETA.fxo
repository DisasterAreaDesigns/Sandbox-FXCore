// ----------------------------------------------------------------------------------------------------------------------------------------
// CYBERATTACK X ALEXANDER
//
// 
//
// TODO
// Update microcontroller for LFO selection
// toggle controls for all modules - bypass done
// advanced modes for all modules
//
//
// DONE
// pitch module (advanced mode)
// crush module
// reverb mix module
//
// ----------------------------------------------------------------------------------------------------------------------------------------


// ----------------------------------------------------------------------------------------------------------------------------------------
// VARIABLES AND MEMORY
// ----------------------------------------------------------------------------------------------------------------------------------------

.rn	krt		r0           ; reverb time
.rn	kdiff		r1           ; input AP diffusion coefficients
.rn	lpr		r2           ; low pass 
.rn	kfl		r3           ; lp coeff
.rn	klevel	r4           ; reverb level
.rn	coeff		r5
// .rn	inputsample	r6
.rn	lastsample	r7
// .rn	alias_wave	r8

.rn	ledFlag	r10
.rn	feedback	r11
.rn	trails	r12
.rn	killdry	r13
.rn   temp		r14
.rn	temp2		r15


.equ	shiftbase    -2097152   ; shift of +1 octave

.equ	fs		24000
.equ	freq		0.45
.equ	pi		3.14159
.equ	lfo_f_coeff	(2*pi*freq)/fs

.sreg	lfo0_f	lfo_f_coeff 

.creg	kfl	0.5

.mem	ap1	820	; all-pass block 1
.mem	ap2	867	; all-pass block 2
.mem	ap3	1578	; all-pass block 3
.mem	ap4	690	; all-pass block 4
.mem	apc1	4402	; loop all-pass 1
.mem	apc2	3202	; loop all-pass 2
.mem	dc	10678	; loop delay
.mem	predelay	8000	; predelay
.mem	pdel	2048	; pitch shift delay

.equ  kapi	0.65	; all-pass coefficients
.equ  kap	0.6

xor		acc32, acc32	; clear acc
cpy_cc	feedback, acc32
cpy_cc	killdry, acc32
cpy_cc	trails, acc32

// init switch register, this overrides whatever the microcontroller is sending, for testing purposes
// do this BEFORE we read them in the program, don't change on the fly

cpy_cm	acc32, mswitch
ori		acc32, mautofade	; set to ON
ori		acc32, mTrails	; set to ON
;ori		acc32, mInput	; set ON for stereo input
;ori		acc32, mOutput
cpy_mc	mswitch, acc32
xor		acc32, acc32

// @leap01.inputBypassInvertPhase(inputL, inputR, mixL, mixR, inputSum, mswitch, temp, temp2)
CPY_CS ACC32 , IN0    // from library: leap01 -- subroutine: inputBypassInvertPhase -- 
MULTRI ACC32 , -1.0    // from library: leap01 -- subroutine: inputBypassInvertPhase --  Complex equation substitution
CPY_MC INPUTL , ACC32    // from library: leap01 -- subroutine: inputBypassInvertPhase -- matching IN_L with INPUTL type MREG -- 
CPY_MC MIXL , ACC32    // from library: leap01 -- subroutine: inputBypassInvertPhase -- matching MIX_L with MIXL type MREG -- 
CPY_CM ACC32 , MSWITCH    // from library: leap01 -- subroutine: inputBypassInvertPhase -- matching SWITCH with MSWITCH type MREG -- 
ANDI ACC32 , MINPUT    // from library: leap01 -- subroutine: inputBypassInvertPhase -- 
JZ ACC32 , DOMONO_82    // from library: leap01 -- subroutine: inputBypassInvertPhase -- 
DOSTEREO_82: 
CPY_CS ACC32 , IN1    // from library: leap01 -- subroutine: inputBypassInvertPhase -- 
MULTRI ACC32 , -1.0    // from library: leap01 -- subroutine: inputBypassInvertPhase --  Complex equation substitution
CPY_MC INPUTR , ACC32    // from library: leap01 -- subroutine: inputBypassInvertPhase -- matching IN_R with INPUTR type MREG -- 
CPY_MC MIXR , ACC32    // from library: leap01 -- subroutine: inputBypassInvertPhase -- matching MIX_R with MIXR type MREG -- 
SRA ACC32 , 1    // from library: leap01 -- subroutine: inputBypassInvertPhase -- 
CPY_CC TEMP , ACC32    // from library: leap01 -- subroutine: inputBypassInvertPhase -- matching TEMP_SUB with TEMP type CREG -- 
CPY_CM TEMP2 , INPUTL    // from library: leap01 -- subroutine: inputBypassInvertPhase -- matching TEMP_SUB2 with TEMP2 type CREG -- matching IN_L with INPUTL type MREG -- 
SRA TEMP2 , 1    // from library: leap01 -- subroutine: inputBypassInvertPhase -- matching TEMP_SUB2 with TEMP2 type CREG -- 
ADDS ACC32 , TEMP    // from library: leap01 -- subroutine: inputBypassInvertPhase -- matching TEMP_SUB with TEMP type CREG -- 
CPY_MC INPUTSUM , ACC32    // from library: leap01 -- subroutine: inputBypassInvertPhase -- matching IN_SUM with INPUTSUM type MREG -- 
JMP CHECKOUTPUT_82    // from library: leap01 -- subroutine: inputBypassInvertPhase -- 
DOMONO_82: 
CPY_CM ACC32 , INPUTL    // from library: leap01 -- subroutine: inputBypassInvertPhase -- matching IN_L with INPUTL type MREG -- 
CPY_MC INPUTR , ACC32    // from library: leap01 -- subroutine: inputBypassInvertPhase -- matching IN_R with INPUTR type MREG -- 
CPY_MC MIXR , ACC32    // from library: leap01 -- subroutine: inputBypassInvertPhase -- matching MIX_R with MIXR type MREG -- 
CPY_MC INPUTSUM , ACC32    // from library: leap01 -- subroutine: inputBypassInvertPhase -- matching IN_SUM with INPUTSUM type MREG -- 
JMP CHECKOUTPUT_82    // from library: leap01 -- subroutine: inputBypassInvertPhase -- 
CHECKOUTPUT_82: 
CPY_CM ACC32 , MSWITCH    // from library: leap01 -- subroutine: inputBypassInvertPhase -- matching SWITCH with MSWITCH type MREG -- 
ANDI ACC32 , MOUTPUT    // from library: leap01 -- subroutine: inputBypassInvertPhase -- 
JNZ ACC32 , CHECKBYPASS_82    // from library: leap01 -- subroutine: inputBypassInvertPhase -- 
CPY_CM ACC32 , INPUTSUM    // from library: leap01 -- subroutine: inputBypassInvertPhase -- matching IN_SUM with INPUTSUM type MREG -- 
CPY_MC INPUTL , ACC32    // from library: leap01 -- subroutine: inputBypassInvertPhase -- matching IN_L with INPUTL type MREG -- 
CPY_MC INPUTR , ACC32    // from library: leap01 -- subroutine: inputBypassInvertPhase -- matching IN_R with INPUTR type MREG -- 
CHECKBYPASS_82: 
CPY_CM ACC32 , MSWITCH    // from library: leap01 -- subroutine: inputBypassInvertPhase -- matching SWITCH with MSWITCH type MREG -- 
ANDI ACC32 , MBYPASS    // from library: leap01 -- subroutine: inputBypassInvertPhase -- 
JNZ ACC32 , SUB_END_82    // from library: leap01 -- subroutine: inputBypassInvertPhase -- 
XOR ACC32 , ACC32    // from library: leap01 -- subroutine: inputBypassInvertPhase -- 
CPY_MC INPUTSUM , ACC32    // from library: leap01 -- subroutine: inputBypassInvertPhase -- 
CPY_MC INPUTL , ACC32    // from library: leap01 -- subroutine: inputBypassInvertPhase -- matching IN_L with INPUTL type MREG -- 
CPY_MC INPUTR , ACC32    // from library: leap01 -- subroutine: inputBypassInvertPhase -- matching IN_R with INPUTR type MREG -- 
SUB_END_82: 
XOR ACC32 , ACC32    // from library: leap01 -- subroutine: inputBypassInvertPhase -- 
// end inclusion library leap01 --  subroutine inputBypassInvertPhase


// ----------------------------------------------------------------------------------------------------------------------------------------
// START OF USER PROGRAM
// ----------------------------------------------------------------------------------------------------------------------------------------

// start with bit crush + sample reducer

// feed into reverb

// then into pitch shifters

// then trem / slicer

; put preceding stage audio into the audio bucket for the next module first
cpy_cm	acc32, inputSum
cpy_mc	audioCrush, acc32

; then check bypass for that module
cpy_cm	acc32, toggle	; we only need to check the "MID" position
andi		acc32, sw4mid	; of each bypass switch for this
jz		acc32, doCrush	; we do need to check low and high for
jmp		crushDone		

doCrush:
; bypass aliaser at lower pot settings
cpy_cm	acc32, potM
addsi		acc32, -0.05		; start aliasing sooner!
jgez		acc32, aliastime		; if pot is high we do the aliasing
cpy_cm	temp, audioCrush		; if not we pass the audio from the bucket to the bitcrusher
jmp		noalias			; and skip aliaser

aliastime:
cpy_cm	temp2, alias_wave

cpy_cm	acc32,potM
addsi		acc32, -1.0
neg		acc32
multri	acc32, 0.296
addsi		acc32, 0.004
add		acc32, temp2		; add in last counter value
cpy_mc	alias_wave, acc32		
addi		acc32, -0.5
jneg		acc32, noalias

cpy_mc	alias_wave, acc32		; save oscillator / counter value
cpy_cc	temp, lastsample		; copy last good sample into output
cpy_cm	lastsample, audioCrush	; load in new sample from ADC

noalias:

; bit crushing module
cpy_cm	temp2, potN		; get pot N
cpy_cm	acc32, one
subs		acc32, temp2	; do 1-pot
cpy_cc	temp2, acc32	; hold it
multrr	temp2, temp2		; now (1-pot)^2
multrr	temp2, acc32		; now ^3
multrr	temp2, acc32		; now ^3
cpy_cc	temp2, acc32
cpy_cm	acc32, one		; put 1 in acc
subs		acc32, temp2	
multri	acc32, 0.9
sr		acc32, 26		; shift down to an 5 bit number
cpy_cc	temp2, acc32	; store in temp

srar		temp, temp2		; shift down to bit crush
slsr		acc32, temp2	; shift back up
cpy_mc	audioCrush, acc32	; and store in bucket

crushDone:
cpy_cm	acc32, audioCrush	; pull audio out of bucket for this module

; pitch shifting module, after reverb
cpy_mc	audioPitch, acc32	; fill bucket so we can bypass later if needed
wrdel		pdel, acc32		; and always fill the pitch delay line

; then check bypass for that module
cpy_cm	acc32, toggle	; we only need to check the "MID" position
andi		acc32, sw3mid	; of each bypass switch for this
jz		acc32, doPitch	; we do need to check low and high for
jmp		pitchDone

doPitch:
// this gets the pitch shift coefficients from lookup table
cpy_cm 	acc32, potI 	; copy pitch pot into ACC
sr 		acc32, 26		; shift right so we only have 32 / 5 bits
cpy_cmx 	temp2, acc32	; the old funcion used temp2, so we'll just re-use that

wrdld		temp,shiftbase.u	; Put upper part of shiftbase into temp
ori		temp, shiftbase.l
multrr	temp2, temp		; Multiply the adjusted POT0 value by shiftbase
cpy_sc	ramp0_f, acc32    ; Write the result to the ramp1 frequency control

pitch		rmp0|L2048|XF0, pdel	; Do the shift, result will be in ACC32
cpy_mc	pitch1, acc32	; put back in wet

cpy_cm 	acc32, potJ 	; copy pitch pot into ACC
sr 		acc32, 26		; shift right so we only have 32 / 5 bits
cpy_cmx 	temp2, acc32	; the old funcion used temp2, so we'll just re-use that

wrdld		temp,shiftbase.u	; Put upper part of shiftbase into temp
ori		temp, shiftbase.l
multrr	temp2, temp		; Multiply the adjusted POT0 value by shiftbase
cpy_sc	ramp1_f, acc32    ; Write the result to the ramp1 frequency control

pitch		rmp1|L2048|XF0, pdel	; Do the shift, result will be in ACC32
cpy_mc	pitch2, acc32	; put back in wet

; pitch mixer
cpy_cm	acc32, potL		; get pot
cpy_cm	temp, pitch2	; pitch 2 goes up as we turn CW
multrr	acc32, temp		; scale pitch
cpy_cc	temp2, acc32	; store scaled pitch

cpy_cm	acc32, potL		; get pot
neg		acc32			; invert response
addsi		acc32, 0.99999	; now ranges from 1 to 0
cpy_cm	temp, pitch1	; pitch 2 goes up as we turn CW
multrr	acc32, temp		; scale pitch
adds		temp2, acc32	; add pitch1 and pitch2

cpy_cm	temp, potK		; and scale by wet / dry mixer
multrr	temp, acc32		; now we have scaled 1+2
cpy_cc	temp2, acc32	; store

cpy_cm	acc32, potK		; get pot
neg		acc32			; invert response
addsi		acc32, 0.99999	; now ranges from 1 to 0
cpy_cm	temp, audioPitch	; pthis is the input bucket, still clean
multrr	acc32, temp		; scale pitch
adds		temp2, acc32	; and add in wet signal

sls		acc32, 1

cpy_mc	audioPitch, acc32	; fill bucket with processed audio

pitchDone:

; reverb shifting module, after pitch?
cpy_cm	acc32, audioPitch		; get bucket
cpy_mc	audioReverb, acc32	; fill bucket so we can bypass later if needed
wrdel		predelay, acc32

cpy_cm	acc32, potD		; delay pot
multri	acc32, 0.99
addsi		acc32, 0.0001
cpy_cc	temp, acc32
wrdld		temp2, predelay!

; do predelay read
multrr	temp, temp2		; read delay position
interp	acc32, predelay	; now predelay is in the acc

; get input to to first string of APs
;cpy_cc    acc32, input	; changed for aliasier
sra       acc32, 1
apra      kdiff, ap1#
aprb      kdiff, ap1
apra      kdiff, ap2#
aprb      kdiff, ap2
apra      kdiff, ap3#
aprb      kdiff, ap3
apa       kapi, ap4#
apa       -kapi, ap4
cpy_cc    temp, acc32	; put to the side for now

rddel     acc32, dc#	; read head of delay line
subs      acc32, lpr	; lp filter so: acc32 = input - lp
multrr    acc32, kfl	; acc32*K2
adds      acc32, lpr	; acc32+lp
cpy_cc    lpr, acc32	; write back to lp
multrr    krt, acc32	; multiply by reverb time
adds      acc32, temp	; add in input all-pass
apa       kap, apc1#
apb       -kap, apc1
apa       kap, apc2#
apb       -kap, apc2
wrdel     dc, acc32	; and back into loop

clracc64			; clear the 64-bit accumulator
machid    0.8, dc		; add in taps from delays
machid    0.7, dc+4315
machid    0.6, dc#
sat64     acc32		; copy upper 32 bits to acc32 and saturate

sls		acc32, 2	; add gain
cpy_cc	temp, acc32	; put in temp for later

; then check bypass for that module
cpy_cm	acc32, toggle	; we only need to check the "MID" position
andi		acc32, sw1mid	; of each bypass switch for this
jz		acc32, doReverb	; we do need to check low and high for
jmp		reverbDone

doReverb:

cpy_mc	audioReverb, temp	; if we are using the reverb we put temp in here

reverbDone:

; otherwise we use the unprocessed feed from earlier

; tremolo module, last in line before output

cpy_cm	acc32, audioReverb	; get contents of previous bucket
cpy_mc	audioTrem, acc32		; and fill this bucket

; then check bypass for that module
cpy_cm	acc32, toggle	; we only need to check the "MID" position
andi		acc32, sw2mid	; of each bypass switch for this
jz		acc32, doTrem	; we do need to check low and high for
jmp		tremDone

doTrem:

cpy_cm	acc32, potF		; this is depth pot
cpy_cm	temp, potLFO	; get main LFO
multrr	acc32, temp		; now we have scaled LFO
cpy_cm	temp, one		; put 1 in temp
subs		temp, acc32		; now we have 1-LFO here
cpy_cm	temp, audioTrem	; get audio from bucket
multrr	temp, acc32		; and do tremolo
cpy_mc	audioTrem, acc32	; store here to fill bucket, trem is easy

// cpy_cm	acc32, potLFO
// cpy_cm	temp, audioTrem
// multrr	acc32, temp
// cpy_mc	audioTrem, acc32

tremDone:

; tone control

cpy_cm    	acc32, potO		; tone and vol are always active
multri	acc32, -1.0
addsi		acc32, 0.999
multri    	acc32, 0.805
wrdld     	temp, 28737       ; put 0.877... into r0
subs      	temp, acc32
cpy_cc    	temp, acc32		; tone coeff is in temp
cpy_cm	temp2, lp
cpy_cm	acc32, audioTrem	; replace this with the last module in line
subs		acc32, temp2	; lp filter so: acc32 = input - lp
multrr	acc32, temp		; acc32*K2
adds		acc32, temp2	; acc32+lp
cpy_mc	lp, acc32		; write back to lp

sra		acc32, 1		; gain boost before output
cpy_mc	outputL, acc32
cpy_mc	outputR, acc32

// ----------------------------------------------------------------------------------------------------------------------------------------
// END OF USER PROGRAM
// ----------------------------------------------------------------------------------------------------------------------------------------

; macro for generating auto fade ramp
; checks bypass switch and if we are set to use trails, it generates a slow ramp that fades out the wet signal

// @leap01.autoFadeVariable(outputL, outputR, mswitch, autoFade, feedback, -0.00000003, temp, temp2)
CPY_CM TEMP2 , MSWITCH    // from library: leap01 -- subroutine: autoFadeVariable -- matching TEMP_SUB2 with TEMP2 type CREG -- matching SWITCH_SUB with MSWITCH type MREG -- 
ANDI TEMP2 , MBYPASS    // from library: leap01 -- subroutine: autoFadeVariable -- matching TEMP_SUB2 with TEMP2 type CREG -- 
JZ ACC32 , DOAUTOFADE_341    // from library: leap01 -- subroutine: autoFadeVariable -- 
WRDLD TEMP , 0X7FFF    // from library: leap01 -- subroutine: autoFadeVariable -- matching TEMP_SUB with TEMP type CREG -- 
ORI TEMP , 0XFFFF    // from library: leap01 -- subroutine: autoFadeVariable -- matching TEMP_SUB with TEMP type CREG -- 
CPY_MC AUTOFADE , TEMP    // from library: leap01 -- subroutine: autoFadeVariable -- matching AUTOFADE_SUB with AUTOFADE type MREG -- matching TEMP_SUB with TEMP type CREG -- 
DOAUTOFADE_341: 
CPY_CS ACC32 , SAMPLECNT    // from library: leap01 -- subroutine: autoFadeVariable -- 
ANDI ACC32 , 0X7    // from library: leap01 -- subroutine: autoFadeVariable -- 
JNZ ACC32 , SUBTRACTFADE_341    // from library: leap01 -- subroutine: autoFadeVariable -- 
CPY_CM ACC32 , AUTOFADE    // from library: leap01 -- subroutine: autoFadeVariable -- matching AUTOFADE_SUB with AUTOFADE type MREG -- 
ADDSI ACC32 , -0.00000003    // from library: leap01 -- subroutine: autoFadeVariable -- matching FADE_TIME with -0.00000003 type DECIMAL -- 
JNEG ACC32 , SUBTRACTFADE_341    // from library: leap01 -- subroutine: autoFadeVariable -- 
CPY_MC AUTOFADE , ACC32    // from library: leap01 -- subroutine: autoFadeVariable -- matching AUTOFADE_SUB with AUTOFADE type MREG -- 
SUBTRACTFADE_341: 
ANDI TEMP2 , MAUTOFADE    // from library: leap01 -- subroutine: autoFadeVariable -- matching TEMP_SUB2 with TEMP2 type CREG -- 
JZ ACC32 , SUB_END_341    // from library: leap01 -- subroutine: autoFadeVariable -- 
CPY_CM TEMP , AUTOFADE    // from library: leap01 -- subroutine: autoFadeVariable -- matching TEMP_SUB with TEMP type CREG -- matching AUTOFADE_SUB with AUTOFADE type MREG -- 
CPY_CM ACC32 , OUTPUTL    // from library: leap01 -- subroutine: autoFadeVariable -- matching OUT_L with OUTPUTL type MREG -- 
MULTRR TEMP , ACC32    // from library: leap01 -- subroutine: autoFadeVariable -- matching TEMP_SUB with TEMP type CREG -- 
CPY_MC OUTPUTL , ACC32    // from library: leap01 -- subroutine: autoFadeVariable -- matching OUT_L with OUTPUTL type MREG -- 
CPY_CM ACC32 , OUTPUTR    // from library: leap01 -- subroutine: autoFadeVariable -- matching OUT_R with OUTPUTR type MREG -- 
MULTRR TEMP , ACC32    // from library: leap01 -- subroutine: autoFadeVariable -- matching TEMP_SUB with TEMP type CREG -- 
CPY_MC OUTPUTR , ACC32    // from library: leap01 -- subroutine: autoFadeVariable -- matching OUT_R with OUTPUTR type MREG -- 
MULTRR FEEDBACK , TEMP    // from library: leap01 -- subroutine: autoFadeVariable -- matching FEEDBACK_SUB with FEEDBACK type CREG -- matching TEMP_SUB with TEMP type CREG -- 
CPY_CC FEEDBACK , ACC32    // from library: leap01 -- subroutine: autoFadeVariable -- matching FEEDBACK_SUB with FEEDBACK type CREG -- 
SUB_END_341: 
XOR ACC32 , ACC32    // from library: leap01 -- subroutine: autoFadeVariable -- 
// end inclusion library leap01 --  subroutine autoFadeVariable


; mixer section, handles killing trails if necessary

// @leap01.doMixer(mixL, mixR, outputL, outputR, potC, potP, mswitch, killdry, trails, feedback, temp, temp2)
DOMIXPOT_345: 
CPY_CM ACC32 , POTC    // from library: leap01 -- subroutine: doMixer -- matching MIX_POT with POTC type MREG -- 
MULTRR ACC32 , ACC32    // from library: leap01 -- subroutine: doMixer -- 
MULTRR ACC32 , ACC32    // from library: leap01 -- subroutine: doMixer -- 
MULTRR ACC32 , ACC32    // from library: leap01 -- subroutine: doMixer -- 
MULTRR ACC32 , ACC32    // from library: leap01 -- subroutine: doMixer -- 
CPY_CC TEMP , ACC32    // from library: leap01 -- subroutine: doMixer -- matching TEMP_SUB with TEMP type CREG -- 
WRDLD ACC32 , 0X7FFF    // from library: leap01 -- subroutine: doMixer -- 
ORI ACC32 , 0XFFFF    // from library: leap01 -- subroutine: doMixer -- 
SUBS ACC32 , TEMP    // from library: leap01 -- subroutine: doMixer -- matching TEMP_SUB with TEMP type CREG -- 
CPY_CC KILLDRY , ACC32    // from library: leap01 -- subroutine: doMixer -- matching KILLDRY_SUB with KILLDRY type CREG -- 
CPY_CM ACC32 , POTP    // from library: leap01 -- subroutine: doMixer -- matching VOL_POT with POTP type MREG -- 
MULTRI ACC32 , 0.5    // from library: leap01 -- subroutine: doMixer -- 
ADDSI ACC32 , 0.5    // from library: leap01 -- subroutine: doMixer -- 
CPY_CC TEMP2 , ACC32    // from library: leap01 -- subroutine: doMixer -- matching TEMP_SUB2 with TEMP2 type CREG -- 
WRDLD TRAILS , 0.99999*32767    // from library: leap01 -- subroutine: doMixer -- matching TRAILS_SUB with TRAILS type CREG --  Complex equation substitution
CPY_CM TEMP , MSWITCH    // from library: leap01 -- subroutine: doMixer -- matching TEMP_SUB with TEMP type CREG -- matching SWITCH_SUB with MSWITCH type MREG -- 
ANDI TEMP , MBYPASS    // from library: leap01 -- subroutine: doMixer -- matching TEMP_SUB with TEMP type CREG -- 
JNZ ACC32 , MIXER_SUB_345    // from library: leap01 -- subroutine: doMixer -- 
WRDLD TEMP2 , 0.99999*32767    // from library: leap01 -- subroutine: doMixer -- matching TEMP_SUB2 with TEMP2 type CREG --  Complex equation substitution
WRDLD KILLDRY , 0.99999*32767    // from library: leap01 -- subroutine: doMixer -- matching KILLDRY_SUB with KILLDRY type CREG --  Complex equation substitution
ANDI TEMP , MTRAILS    // from library: leap01 -- subroutine: doMixer -- matching TEMP_SUB with TEMP type CREG -- 
JNZ ACC32 , MIXER_SUB_345    // from library: leap01 -- subroutine: doMixer -- 
WRDLD TRAILS , 0    // from library: leap01 -- subroutine: doMixer -- matching TRAILS_SUB with TRAILS type CREG -- 
MIXER_SUB_345: 
MULTRR FEEDBACK , TRAILS    // from library: leap01 -- subroutine: doMixer -- matching FEEDBACK_SUB with FEEDBACK type CREG -- matching TRAILS_SUB with TRAILS type CREG -- 
CPY_CC FEEDBACK , ACC32    // from library: leap01 -- subroutine: doMixer -- matching FEEDBACK_SUB with FEEDBACK type CREG -- 
CPY_CM ACC32 , OUTPUTL    // from library: leap01 -- subroutine: doMixer -- matching OUT_L with OUTPUTL type MREG -- 
CPY_CM TEMP , POTC    // from library: leap01 -- subroutine: doMixer -- matching TEMP_SUB with TEMP type CREG -- matching MIX_POT with POTC type MREG -- 
MULTRR ACC32 , TEMP    // from library: leap01 -- subroutine: doMixer -- matching TEMP_SUB with TEMP type CREG -- 
MULTRR ACC32 , TRAILS    // from library: leap01 -- subroutine: doMixer -- matching TRAILS_SUB with TRAILS type CREG -- 
CPY_CC TEMP , ACC32    // from library: leap01 -- subroutine: doMixer -- matching TEMP_SUB with TEMP type CREG -- 
CPY_CM ACC32 , MIXL    // from library: leap01 -- subroutine: doMixer -- matching IN_L with MIXL type MREG -- 
MULTRR ACC32 , KILLDRY    // from library: leap01 -- subroutine: doMixer -- matching KILLDRY_SUB with KILLDRY type CREG -- 
ADDS TEMP , ACC32    // from library: leap01 -- subroutine: doMixer -- matching TEMP_SUB with TEMP type CREG -- 
MULTRR ACC32 , TEMP2    // from library: leap01 -- subroutine: doMixer -- matching TEMP_SUB2 with TEMP2 type CREG -- 
CPY_SC OUT0 , ACC32    // from library: leap01 -- subroutine: doMixer -- 
CPY_CM ACC32 , OUTPUTR    // from library: leap01 -- subroutine: doMixer -- matching OUT_R with OUTPUTR type MREG -- 
CPY_CM TEMP , POTC    // from library: leap01 -- subroutine: doMixer -- matching TEMP_SUB with TEMP type CREG -- matching MIX_POT with POTC type MREG -- 
MULTRR ACC32 , TEMP    // from library: leap01 -- subroutine: doMixer -- matching TEMP_SUB with TEMP type CREG -- 
MULTRR ACC32 , TRAILS    // from library: leap01 -- subroutine: doMixer -- matching TRAILS_SUB with TRAILS type CREG -- 
CPY_CC TEMP , ACC32    // from library: leap01 -- subroutine: doMixer -- matching TEMP_SUB with TEMP type CREG -- 
CPY_CM ACC32 , MIXR    // from library: leap01 -- subroutine: doMixer -- matching IN_R with MIXR type MREG -- 
MULTRR ACC32 , KILLDRY    // from library: leap01 -- subroutine: doMixer -- matching KILLDRY_SUB with KILLDRY type CREG -- 
ADDS ACC32 , TEMP    // from library: leap01 -- subroutine: doMixer -- matching TEMP_SUB with TEMP type CREG -- 
CPY_CC TEMP , ACC32    // from library: leap01 -- subroutine: doMixer -- matching TEMP_SUB with TEMP type CREG -- 
CPY_CM ACC32 , MSWITCH    // from library: leap01 -- subroutine: doMixer -- matching SWITCH_SUB with MSWITCH type MREG -- 
ANDI ACC32 , MPHASE    // from library: leap01 -- subroutine: doMixer -- 
JZ ACC32 , OUTPUT_SUB_345    // from library: leap01 -- subroutine: doMixer -- 
MULTRI TEMP , -1.0    // from library: leap01 -- subroutine: doMixer -- matching TEMP_SUB with TEMP type CREG --  Complex equation substitution
CPY_CC TEMP , ACC32    // from library: leap01 -- subroutine: doMixer -- matching TEMP_SUB with TEMP type CREG -- 
OUTPUT_SUB_345: 
MULTRR TEMP2 , TEMP    // from library: leap01 -- subroutine: doMixer -- matching TEMP_SUB2 with TEMP2 type CREG -- matching TEMP_SUB with TEMP type CREG -- 
CPY_SC OUT1 , ACC32    // from library: leap01 -- subroutine: doMixer -- 
// end inclusion library leap01 --  subroutine doMixer


// ----------------------------------------------------------------------------------------------------------------------------------------
// POT READING
// Uses I2S interface 1 to read control data from microcontroller
// ----------------------------------------------------------------------------------------------------------------------------------------

; memory arrangement:
; toggle mr125
; switch mr126
; pots mr98-105
; pot filter mr107-mr122
; LFO mr106
; LFO filter mr123-124

doPot:
; read I2S interface
cpy_cs	temp, in2	; read I2S data
andi		temp, 0x00FF	; mask off upper bits, index is in 8 LSBs
jz		acc32, done		; if it's zero don't bother with the rest
cpy_cc	temp2, acc32	; index is stored

xori		acc32, 0x007F	; if index = 127 then do switch
jnz		acc32, matchTog	; otherwise do pots
sr		temp, 17	; shift control data right 15 to get a 16-bit number
cpy_mc	mswitch, acc32	; store in mswitch and out
jmp		done

matchTog:
;f the control data points to a pot, then we put the incoming new value into an MREG
; and then we skip the rest of these steps, go to filter section
xori		temp2, 0x006F	; if index = 127 then do switch
jnz		acc32, matchPot	; otherwise do pots
sr		temp, 20	; shift control data right 21 to get a 10-bit number
cpy_mc	toggle, acc32	; store in toggle and out
jmp		done

matchPot:

doPotAB:
xori		temp2, 0x0065
jnz		acc32, doPotCD
cpy_mc	holdAB, temp	; store

dopotCD:
xori		temp2, 0x0066
jnz		acc32, doPotEF
cpy_mc	holdCD, temp		; copy to C holding

doPotEF:
xori		temp2, 0x0067
jnz		acc32, doPotGH
cpy_mc	holdEF, temp		; copy to F holding

doPotGH:
xori		temp2, 0x0068
jnz		acc32, doPotIJ
cpy_mc	holdGH, temp		; copy to H holding

doPotIJ:
xori		temp2, 0x0069
jnz		acc32, doPotKL
cpy_mc	holdIJ, temp		; copy to J holding

doPotKL:
xori		temp2, 0x006A
jnz		acc32, doPotMN
cpy_mc	holdKL, temp	; copy to L holding

doPotMN:
xori		temp2, 0x006B
jnz		acc32, doPotOP
cpy_mc	holdMN, temp	; copy to N holding

doPotOP:
xori		temp2, 0x006C
jnz		acc32, doPotLFO
cpy_mc	holdOP, temp	; copy to P holding

doPotLFO:
xori		temp2, 0x0075
jnz		acc32, done
cpy_mc	holdLFO, temp	; copy to P holding

done:
; filter A
cpy_cm	acc32, holdAB	; get pot value
sr		acc32, 21
sl		acc32, 21
cpy_cm	temp, potA		; get old filter value
subs		acc32, temp
multri	acc32, kpotA	; acc32*K2
adds		acc32, temp		; acc32+lp
cpy_mc	potA, acc32		; write back to lp

; filter B
cpy_cm	acc32, holdAB	; get pot value
sr		acc32, 11
andi		acc32, 0x03FF	; mask off lower bits
sl		acc32, 21		; bump back to 32 bits
cpy_cm	temp, potB		; get old filter value
subs		acc32, temp		; lp filter so: acc32 = input - lp
multri	acc32, kpotB     	; acc32*K2
adds		acc32, temp		; acc32+lp
cpy_mc	potB, acc32    	; write back to lp

; filter C
cpy_cm	acc32, holdCD	; get pot value
sr		acc32, 21
sl		acc32, 21
cpy_cm	temp, potC		; get old filter value
subs		acc32, temp
multri	acc32, kpotC	; acc32*K2
adds		acc32, temp		; acc32+lp
cpy_mc	potC, acc32		; write back to lp

; filter D
cpy_cm	acc32, holdCD	; get pot value
sr		acc32, 11
andi		acc32, 0x03FF	; mask off lower bits
sl		acc32, 21		; bump back to 32 bits
cpy_cm	temp, potD		; get old filter value
subs		acc32, temp		; lp filter so: acc32 = input - lp
multri	acc32, kpotD     	; acc32*K2
adds		acc32, temp		; acc32+lp
cpy_mc	potD, acc32    	; write back to lp

; filter E
cpy_cm	acc32, holdEF	; get pot value
sr		acc32, 21
sl		acc32, 21
cpy_cm	temp, potE		; get old filter value
subs		acc32, temp
multri	acc32, kpotE	; acc32*K2
adds		acc32, temp		; acc32+lp
cpy_mc	potE, acc32		; write back to lp

; filter F
cpy_cm	acc32, holdEF	; get pot value
sr		acc32, 11
andi		acc32, 0x03FF	; mask off lower bits
sl		acc32, 21		; bump back to 32 bits
cpy_cm	temp, potF		; get old filter value
subs		acc32, temp		; lp filter so: acc32 = input - lp
multri	acc32, kpotF     	; acc32*K2
adds		acc32, temp		; acc32+lp
cpy_mc	potF, acc32    	; write back to lp

; filter G
cpy_cm	acc32, holdGH	; get pot value
sr		acc32, 21
sl		acc32, 21
cpy_cm	temp, potG		; get old filter value
subs		acc32, temp
multri	acc32, kpotG	; acc32*K2
adds		acc32, temp		; acc32+lp
cpy_mc	potG, acc32		; write back to lp

; filter H
cpy_cm	acc32, holdGH	; get pot value
sr		acc32, 11
andi		acc32, 0x03FF	; mask off lower bits
sl		acc32, 21		; bump back to 32 bits
cpy_cm	temp, potH		; get old filter value
subs		acc32, temp		; lp filter so: acc32 = input - lp
multri	acc32, kpotH     	; acc32*K2
adds		acc32, temp		; acc32+lp
cpy_mc	potH, acc32    	; write back to lp

; filter I
cpy_cm	acc32, holdIJ	; get pot value
sr		acc32, 21
sl		acc32, 21
cpy_cm	temp, potI		; get old filter value
subs		acc32, temp
multri	acc32, kpotI	; acc32*K2
adds		acc32, temp		; acc32+lp
cpy_mc	potI, acc32		; write back to lp

; filter J
cpy_cm	acc32, holdIJ	; get pot value
sr		acc32, 11
andi		acc32, 0x03FF	; mask off lower bits
sl		acc32, 21		; bump back to 32 bits
cpy_cm	temp, potJ		; get old filter value
subs		acc32, temp		; lp filter so: acc32 = input - lp
multri	acc32, kpotJ     	; acc32*K2
adds		acc32, temp		; acc32+lp
cpy_mc	potJ, acc32    	; write back to lp

; filter K
cpy_cm	acc32, holdKL	; get pot value
sr		acc32, 21
sl		acc32, 21
cpy_cm	temp, potK		; get old filter value
subs		acc32, temp
multri	acc32, kpotK	; acc32*K2
adds		acc32, temp		; acc32+lp
cpy_mc	potK, acc32		; write back to lp

; filter L
cpy_cm	acc32, holdKL	; get pot value
sr		acc32, 11
andi		acc32, 0x03FF	; mask off lower bits
sl		acc32, 21		; bump back to 32 bits
cpy_cm	temp, potL		; get old filter value
subs		acc32, temp		; lp filter so: acc32 = input - lp
multri	acc32, kpotL     	; acc32*K2
adds		acc32, temp		; acc32+lp
cpy_mc	potL, acc32    	; write back to lp

; filter M
cpy_cm	acc32, holdMN	; get pot value
sr		acc32, 21
sl		acc32, 21
cpy_cm	temp, potM		; get old filter value
subs		acc32, temp
multri	acc32, kpotM	; acc32*K2
adds		acc32, temp		; acc32+lp
cpy_mc	potM, acc32		; write back to lp

; filter N
cpy_cm	acc32, holdMN	; get pot value
sr		acc32, 11
andi		acc32, 0x03FF	; mask off lower bits
sl		acc32, 21		; bump back to 32 bits
cpy_cm	temp, potN		; get old filter value
subs		acc32, temp		; lp filter so: acc32 = input - lp
multri	acc32, kpotN     	; acc32*K2
adds		acc32, temp		; acc32+lp
cpy_mc	potN, acc32    	; write back to lp

; filter O
cpy_cm	acc32, holdOP	; get pot value
sr		acc32, 21
sl		acc32, 21
cpy_cm	temp, potO		; get old filter value
subs		acc32, temp
multri	acc32, kpotO	; acc32*K2
adds		acc32, temp		; acc32+lp
cpy_mc	potO, acc32		; write back to lp

; filter P
cpy_cm	acc32, holdOP	; get pot value
sr		acc32, 11
andi		acc32, 0x03FF	; mask off lower bits
sl		acc32, 21		; bump back to 32 bits
cpy_cm	temp, potP		; get old filter value
subs		acc32, temp		; lp filter so: acc32 = input - lp
multri	acc32, kpotP     	; acc32*K2
adds		acc32, temp		; acc32+lp
cpy_mc	potP, acc32    	; write back to lp

; filter LFO
cpy_cm	acc32, holdLFO	; get pot value
sr		acc32, 21
sl		acc32, 21
cpy_cm	temp, potLFO	; get old filter value
subs		acc32, temp		; lp filter so: acc32 = input - lp
multri	acc32, kLFO     	; acc32*K2
adds		acc32, temp		; acc32+lp
cpy_mc	potLFO, acc32    	; write back to lp

; filter LFO2
cpy_cm	acc32, holdLFO	; get pot value
sr		acc32, 11
andi		acc32, 0x03FF	; mask off lower bits
sl		acc32, 21		; bump back to 32 bits
cpy_cm	temp, potLFO2	; get old filter value
subs		acc32, temp		; lp filter so: acc32 = input - lp
multri	acc32, kLFO2	; acc32*K2
adds		acc32, temp		; acc32+lp
cpy_mc	potLFO2, acc32	; write back to lp

// ----------------------------------------------------------------------------------------------------------------------------------------
// CONSTANTS AND DECLARATIONS
// NAMES FOR THINGS WE NEED
// ----------------------------------------------------------------------------------------------------------------------------------------

// smoothing parameters

; filter coefficients for pot filtering
.equ	kpotA		0.01
.equ	kpotB		0.01
.equ	kpotC		0.01
.equ	kpotD		0.0004	; controls INTERP, needs to be smooth
.equ	kpotE		0.01
.equ	kpotF		0.01
.equ	kpotG		0.01
.equ	kpotH		0.01
.equ	kpotI		0.01
.equ	kpotJ		0.01
.equ	kpotK		0.01
.equ	kpotL		0.01
.equ	kpotM		0.01
.equ	kpotN		0.01
.equ	kpotO		0.01
.equ	kpotP		0.01

.equ	kLFO		0.01 ; lfo controls INTERP, make more smooth
.equ	kLFO2		0.008 ; lfo controls INTERP, make more smooth
.equ	kMute		0.0008

; switch values
.equ	mFeedback	0x0080	; set this if we want to increase feedback to max
.equ	mTakeover	0x0100	; set this if we are tapping tempo
.equ	mAutofade	0x0200	; set this to enable auto fade for bypass trails
.equ	mBypass     0x0400	; set this to engage effect, 1 = effect, 0 = bypass
.equ	mTrails     0x0800	; set this to enable input muting and trails for bypass
.equ	mPhase      0x1000	; set this to invert phase for output R
.equ	mInput      0x2000	; 0 = mono input, 1 = stereo input
.equ  mOutput     0x4000	; 0 = mono, l is copied to L&R dry, 1 = stereo, L=L R=R

.equ	sw4hi		0x0080
.equ	sw4mid	0x0040
.equ	sw3hi		0x0020
.equ	sw3mid	0x0010
.equ	sw2hi		0x0008
.equ	sw2mid	0x0004
.equ	sw1hi		0x0002
.equ	sw1mid	0x0001

// chromatic scale, 25 values
.mreg	mr0	-0.50000 ; -12
.mreg	mr1	-0.47021 ; -11
.mreg	mr2	-0.43872 ; -10
.mreg	mr3	-0.43872 ; -10
.mreg	mr4	-0.40540 ; -9
.mreg	mr5	-0.37000 ; -8
.mreg	mr6	-0.33252 ; -7
.mreg	mr7	-0.33252 ; -7
.mreg	mr8	-0.29285 ; -6
.mreg	mr9	-0.25000 ; -5
.mreg	mr10	-0.20630 ; -4
.mreg	mr11	-0.15906 ; -3
.mreg	mr12	-0.15906 ; -3
.mreg	mr13	-0.10907 ; -2
.mreg	mr14	-0.05609 ; -1
.mreg	mr15	0.00000 ; 0
.mreg	mr16	0.00000 ; 0
.mreg	mr17	0.05945 ; 1
.mreg	mr18	0.12244 ; 2
.mreg	mr19	0.18915 ; 3
.mreg	mr20	0.25989 ; 4
.mreg	mr21	0.25989 ; 4
.mreg	mr22	0.33484 ; 5
.mreg	mr23	0.41418 ; 6
.mreg	mr24	0.49999 ; 7
.mreg	mr25	0.58734 ; 8
.mreg	mr26	0.58734 ; 8
.mreg	mr27	0.68176 ; 9
.mreg	mr28	0.78174 ; 10
.mreg	mr29	0.88770 ; 11
.mreg	mr30	0.88770 ; 11
.mreg	mr31	0.99999 ;12

// MREG 32-79 available

.rn	alias_wave	mr60
.rn	pitch1	mr61
.rn	pitch2	mr62

.rn	lp		mr69

.rn	audioCrush	mr70
.rn	audioReverb	mr71
.rn	audioPitch	mr72
.rn	audioTrem	mr73

.rn	inputL	mr80
.rn	inputR	mr81
.rn	inputSum	mr82
.rn	outputL	mr83
.rn	outputR	mr84
.rn	mixL		mr85
.rn	mixR		mr86
.rn	autofade	mr87	; holds fade counter
.rn	env		mr88	; envelope extracted
.rn	bright	mr89	; brightness holding

// MREG 90-97 available

.rn	holdAB	mr98
.rn	holdCD	mr99
.rn	holdEF	mr100
.rn	holdGH	mr101
.rn	holdIJ	mr102
.rn	holdKL	mr103
.rn	holdMN	mr104
.rn	holdOP	mr105
.rn	holdLFO	mr106

.rn	potA	mr107
.rn	potB	mr108
.rn	potC	mr109
.rn	potD	mr110
.rn	potE	mr111
.rn	potF	mr112
.rn	potG	mr113
.rn	potH	mr114
.rn	potI	mr115
.rn	potJ	mr116
.rn	potK	mr117
.rn	potL	mr118
.rn	potM	mr119
.rn	potN	mr120
.rn	potO	mr121
.rn	potP	mr122

.rn	potLFO mr123
.rn	potLFO2 mr124

.rn	toggle mr125
.rn	mswitch mr126

.rn	one mr127
.mreg	one	0x7FFFFFFF	; put 1 in this register
